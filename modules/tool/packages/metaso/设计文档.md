# Metaso 插件设计文档

## 📋 项目概述

### 插件名称
**Metaso 工具集** - 基于 Metaso API 的多功能搜索和问答工具集

### 功能描述
提供三种核心功能：
1. **搜索 (Search)** - 网页内容搜索，支持摘要生成
2. **问答 (Ask)** - 智能问答服务
3. **网页读取 (Reader)** - 指定URL内容提取和解析

### 技术架构
采用 **Children ToolSet** 架构，将三个功能作为独立的子工具组织在一个工具集中。

## 🏗️ 架构设计

### 1. 项目结构
```
metaso/
├── config.ts                    # 工具集主配置
├── index.ts                     # 导出入口
├── logo.svg                     # 工具集图标
├── package.json                 # 包配置
├── shared/                      # 共享模块
│   ├── api.ts                  # Metaso API 客户端
│   ├── config.ts               # 配置管理
│   ├── types.ts                # 通用类型定义
│   └── utils.ts                # 工具函数
├── children/                    # 子工具目录
│   ├── search/                 # 搜索工具
│   │   ├── config.ts          # 搜索工具配置
│   │   ├── index.ts           # 搜索工具导出
│   │   └── src/
│   │       ├── index.ts       # 搜索核心实现
│   │       └── types.ts       # 搜索类型定义
│   ├── ask/                   # 问答工具
│   │   ├── config.ts          # 问答工具配置
│   │   ├── index.ts           # 问答工具导出
│   │   └── src/
│   │       ├── index.ts       # 问答核心实现
│   │       └── types.ts       # 问答类型定义
│   └── reader/                # 网页读取工具
│       ├── config.ts          # 读取工具配置
│       ├── index.ts           # 读取工具导出
│       └── src/
│           ├── index.ts       # 读取核心实现
│           └── types.ts       # 读取类型定义
└── 开发日志.md                 # 开发记录
```

### 2. Children 功能特殊要求

### 2. Children 功能特殊要求

#### 2.1 主配置文件要求
- 必须使用 `defineToolSet` 函数
- 必须包含 `children` 数组，导入所有子工具
- 工具集类型设置为 `ToolTypeEnum.search`（因为主要功能是搜索相关）

#### 2.2 子工具导出要求
- 每个子工具必须使用 `exportTool` 函数
- 导入路径必须是 `'./src'` 而不是 `'./src/index'`
- 必须包含 `toolCb`, `InputType`, `OutputType`, `config` 四个导出项

#### 2.3 共享模块设计
- API 客户端统一管理 Metaso API 调用
- 配置管理强制要求 API Key，提高安全性
- 类型定义采用 Zod 进行运行时验证
- 工具函数提供错误处理和响应格式化

## 🚨 关键错误修复记录

### ⚠️ 重要：versionList 未定义错误

**错误现象**：
```
Cannot read properties of undefined (reading '0')
```

**错误原因**：
1. 在 `modules/tool/init.ts` 的 `LoadToolsByFilename` 函数中，子工具和单个工具的 `versionList` 字段可能为 `undefined`
2. `formatToolList` 函数尝试访问 `item.versionList` 时，如果该字段为 `undefined`，会导致前端访问数组元素时出错

**修复方法**：
在 `modules/tool/init.ts` 中为所有工具添加 `versionList` 保护：

```typescript
// 子工具修复（第65-77行）
for (const child of children) {
  const toolId = child.toolId!;
  tools.push({
    ...child,
    toolId,
    parentId: toolsetId,
    type: rootMod.type,
    courseUrl: rootMod.courseUrl,
    author: rootMod.author,
    icon,
    toolDirName: filename,
    // 🔥 关键修复：确保 versionList 存在
    versionList: child.versionList || []
  });
}

// 单个工具修复（第83-92行）
tools.push({
  ...tool,
  type: tool.type || ToolTypeEnum.tools,
  icon: tool.icon || defaultIcon,
  toolId: tool.toolId || filename,
  toolDirName: filename,
  // 🔥 关键修复：确保 versionList 存在
  versionList: tool.versionList || []
});
```

**预防措施**：
1. 所有工具配置必须包含有效的 `versionList` 数组
2. 在工具加载逻辑中始终提供默认的空数组作为后备
3. 定期检查 `formatToolList` 函数的输入数据完整性

### ⚠️ 异步初始化错误

**错误现象**：
工具可能未完全加载就开始处理请求

**修复方法**：
在 `src/index.ts` 中为 `initTool()` 添加 `await`：

```typescript
// 修复前
initTool();

// 修复后
try {
  await initTool();
} catch (error) {
  console.error('Failed to initialize tools:', error);
  process.exit(1);
}
```

## 🔧 详细设计

### 1. 共享模块设计

#### 1.1 API 客户端 (shared/api.ts)
```typescript
// Metaso API 客户端设计
export class MetasoClient {
  private apiKey: string;
  private baseURL: string = 'https://metaso.cn/api/v1';
  
  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('API Key is required');
    }
    this.apiKey = apiKey;
  }
  
  // 搜索接口
  async search(params: SearchParams): Promise<SearchResponse>
  
  // 问答接口  
  async ask(params: AskParams): Promise<AskResponse>
  
  // 网页读取接口
  async reader(params: ReaderParams): Promise<ReaderResponse>
}
```

#### 1.2 配置管理 (shared/config.ts)
```typescript
// 强制要求 API Key，提高安全性
export function getMetasoConfig(apiKey: string): MetasoConfig {
  if (!apiKey) {
    throw new Error('Metaso API Key is required');
  }
  
  return {
    apiKey,
    baseURL: 'https://metaso.cn/api/v1',
    timeout: 30000
  };
}

// 配置验证
export function validateConfig(config: MetasoConfig): ValidationResult {
  if (!config.apiKey) {
    return { valid: false, error: 'API Key is required' };
  }
  return { valid: true };
}
```

#### 1.3 类型定义 (shared/types.ts)
```typescript
// 使用 Zod 进行类型验证
export const MetasoConfigSchema = z.object({
  apiKey: z.string().min(1, 'API Key cannot be empty'),
  baseURL: z.string().url(),
  timeout: z.number().positive()
});

// 通用响应格式
export const BaseResponseSchema = z.object({
  success: z.boolean(),
  data: z.any().optional(),
  message: z.string(),
  error: z.string().optional()
});
```

### 2. 子工具设计

#### 2.1 搜索工具 (children/search)

**功能描述**: 通过关键词搜索网页内容，支持摘要生成和结果数量控制

**输入参数**:
- `apiKey` (secret, required): Metaso API 密钥
- `query` (string, required): 搜索关键词
  - **工作流集成**: 支持 `reference` 和 `input` 两种输入方式
  - **reference**: 可接收工作流上一节点或起始节点的输出数据
  - **input**: 支持直接手动输入搜索关键词
- `scope` (select, optional): 搜索范围，默认 "webpage"
- `includeSummary` (boolean, optional): 是否包含摘要，默认 false
- `size` (number, optional): 结果数量，默认 10，范围 1-20

**输出结果**:
- `success` (boolean): 执行状态
- `results` (array): 搜索结果列表
- `summary` (string, optional): 搜索摘要
- `message` (string): 结果消息

#### 2.2 问答工具 (children/ask)

**功能描述**: 基于网页内容的智能问答服务

**输入参数**:
- `apiKey` (secret, required): Metaso API 密钥
- `question` (string, required): 问题内容
  - **工作流集成**: 支持 `reference` 和 `input` 两种输入方式
  - **reference**: 可接收工作流上一节点或起始节点的输出数据
  - **input**: 支持直接手动输入问题内容
- `scope` (select, optional): 搜索范围，默认 "webpage"

**输出结果**:
- `success` (boolean): 执行状态
- `answer` (string): 问答结果
- `sources` (array, optional): 参考来源
- `message` (string): 结果消息

#### 2.3 网页读取工具 (children/reader)

**功能描述**: 读取指定URL的网页内容并进行解析

**输入参数**:
- `apiKey` (secret, required): Metaso API 密钥
- `url` (string, required): 目标网页URL
  - **工作流集成**: 支持 `reference` 和 `input` 两种输入方式
  - **reference**: 可接收工作流上一节点或起始节点的输出数据
  - **input**: 支持直接手动输入网页URL
- `format` (select, optional): 输出格式，默认 "text"

**输出结果**:
- `success` (boolean): 执行状态
- `content` (string): 网页内容
- `title` (string, optional): 网页标题
- `message` (string): 结果消息

### 3. 工作流集成配置

#### 3.1 输入参数配置标准
所有主要输入参数（query、question、url）都必须支持工作流集成：

```typescript
{
  key: 'query',  // 参数名
  label: '搜索关键词',
  description: '要搜索的关键词或查询语句',
  toolDescription: '搜索关键词',
  required: true,
  valueType: WorkflowIOValueTypeEnum.string,
  renderTypeList: [
    FlowNodeInputTypeEnum.reference,  // 支持引用其他节点输出
    FlowNodeInputTypeEnum.input       // 支持手动输入
  ]
}
```

#### 3.2 工作流嵌入场景示例

**场景1: 智能搜索链**
```
用户输入 → 关键词提取 → Metaso搜索 → 结果整理 → 回复生成
```

**场景2: 问答增强**
```
用户问题 → 问题分析 → Metaso问答 → 答案验证 → 最终回复
```

**场景3: 网页内容分析**
```
URL输入 → 内容提取(Metaso Reader) → 内容分析 → 摘要生成
```

#### 3.3 参数传递机制
- **reference模式**: 自动接收上一节点的指定输出字段
- **全局变量**: 支持通过FastGPT全局变量传递数据
- **多节点组合**: 支持多个Metaso子工具串联使用

## 🚨 关键技术要点

### 1. Children 架构要求

#### 1.1 主配置文件 (config.ts)
```typescript
import { defineToolSet } from '@tool/type';
import { ToolTypeEnum } from '@tool/type/tool';
import searchTool from './children/search';
import askTool from './children/ask';
import readerTool from './children/reader';

export default defineToolSet({
  name: {
    'zh-CN': 'Metaso 工具集',
    'en-US': 'Metaso Tools'
  },
  description: {
    'zh-CN': '基于 Metaso API 的搜索、问答和网页读取工具集',
    'en-US': 'Search, Q&A and web reading tools based on Metaso API'
  },
  type: ToolTypeEnum.search,
  icon: '/imgs/tools/metaso.svg',
  children: [searchTool, askTool, readerTool]  // 必须包含所有子工具
});
```

#### 1.2 子工具导出 (children/*/index.ts)
```typescript
import config from './config';
import { InputType, OutputType, tool as toolCb } from './src';
import { exportTool } from '@tool/utils/tool';

export default exportTool({
  toolCb,
  InputType,
  OutputType,
  config
});
```

### 2. 统一的输入配置模式

#### 2.1 API Key 配置
```typescript
// 所有子工具都必须包含的 API Key 配置
{
  key: SystemInputKeyEnum.systemInputConfig,
  label: '',
  inputList: [
    {
      key: 'apiKey',
      label: 'Metaso API Key',
      description: 'Metaso 平台的 API 密钥',
      required: true,
      inputType: 'secret'
    }
  ],
  renderTypeList: [FlowNodeInputTypeEnum.hidden],
  valueType: WorkflowIOValueTypeEnum.object
}
```

#### 2.2 业务参数配置
```typescript
// 统一的参数命名规范（驼峰命名）
{
  key: 'query',  // 不是 'q'
  key: 'includeSummary',  // 不是 'include_summary'
  key: 'resultSize'  // 不是 'size'
}
```

### 3. 错误处理机制

#### 3.1 分层错误处理
```typescript
function handleError(error: any): OutputType {
  console.error('[Metaso] 执行失败:', error);
  
  let errorMessage = '操作失败';
  
  if (error instanceof Error) {
    if (error.message.includes('invalid credential')) {
      errorMessage = 'API 密钥无效，请检查您的 Metaso API Key';
    } else if (error.message.includes('timeout')) {
      errorMessage = '请求超时，请稍后重试';
    } else if (error.message.includes('404')) {
      errorMessage = '资源不存在，请检查参数';
    } else {
      errorMessage = `操作失败: ${error.message}`;
    }
  }
  
  return createErrorOutput(errorMessage);
}
```

### 4. 开发顺序要求

#### 4.1 单一功能优先原则
1. **第一阶段**: 开发搜索工具（最简单的功能）
2. **验证阶段**: 确保搜索工具完全正确，构建成功
3. **第二阶段**: 基于搜索工具模板开发问答工具
4. **第三阶段**: 开发网页读取工具
5. **集成阶段**: 完善共享模块和整体测试

#### 4.2 构建验证要求
每个阶段都必须通过以下验证：
- `npm run build` 构建成功
- TypeScript 类型检查通过
- 功能测试验证
- FastGPT 界面正常显示

## 📋 开发检查清单

### 1. 项目结构检查
- [ ] 创建完整的目录结构
- [ ] 添加 logo.svg 图标文件
- [ ] 创建 package.json 配置

### 2. 共享模块检查
- [ ] API 客户端实现完整
- [ ] 配置管理强制要求 API Key
- [ ] 类型定义使用 Zod 验证
- [ ] 工具函数提供完整错误处理

### 3. 子工具检查
- [ ] 每个子工具使用 exportTool 函数
- [ ] 输入配置包含 API Key 和业务参数
- [ ] 输出格式统一且完整
- [ ] 错误处理机制完善

### 4. Children 架构检查
- [ ] 主配置文件导入所有子工具
- [ ] children 数组包含所有子工具
- [ ] 子工具导出结构正确
- [ ] 导入路径使用 './src' 格式

### 5. 构建验证检查
- [ ] 运行 `npm run build` 无错误
- [ ] 生成的文件存在于 dist/tools/ 目录
- [ ] FastGPT 中可以正常显示和使用

## 🎯 预期成果

### 1. 功能完整性
- 三个子工具功能完整且独立
- API 调用稳定可靠
- 错误处理机制完善

### 2. 代码质量
- TypeScript 类型安全
- 代码结构清晰模块化
- 符合 FastGPT 开发规范

### 3. 用户体验
- 配置简单（只需 API Key）
- 功能直观易用
- 错误提示清晰友好

### 4. 可维护性
- 共享模块复用性强
- 子工具独立可扩展
- 文档完整便于维护

## 📝 后续扩展计划

### 1. 功能扩展
- 支持更多搜索范围选项
- 添加结果缓存机制
- 支持批量处理功能

### 2. 性能优化
- 实现请求重试机制
- 添加响应时间监控
- 优化大文件处理

### 3. 用户体验
- 添加进度提示
- 支持结果预览
- 提供使用示例

这个设计文档为 Metaso 插件的开发提供了完整的技术方案和实施指南，特别关注了 Children ToolSet 架构的特殊要求和最佳实践。

## ⚠️ 重要注意事项：构建缓存问题

### 1. 构建缓存的影响

#### 1.1 问题现象
- **界面显示异常**：可能出现空白按钮或重复显示
- **配置不生效**：修改配置文件后界面没有变化
- **功能异常**：工具功能与预期不符

#### 1.2 根本原因
- **缓存残留**：旧的构建缓存中保留了过时的配置信息
- **增量构建**：部分构建工具可能只更新变化的文件，忽略依赖关系
- **配置传播**：配置修改需要通过完整的构建过程才能传播到最终产物

### 2. 强制性构建要求

#### 2.1 配置修改后必须重新构建
```bash
# 任何配置文件修改后都必须执行
npm run build

# 或者在开发环境中
bun run build
```

#### 2.2 关键修改场景
以下修改**必须**立即重新构建：
- 修改任何 `config.ts` 文件
- 修改子工具的导入导出结构
- 修改工具集的 `children` 数组
- 修改图标配置或路径
- 修改工具名称或描述

#### 2.3 构建验证
```bash
# 1. 执行构建
npm run build

# 2. 检查构建日志
# 应该看到类似输出：
# Building metaso...
# metaso build complete

# 3. 验证构建产物
ls -la dist/tools/metaso/

# 4. 测试界面显示
# 在 FastGPT 中检查工具集是否正确显示
```

### 3. 常见错误模式及解决方案

#### 3.1 空白按钮问题
**错误现象**：
- 界面显示额外的空白按钮
- 工具数量与配置不符

**解决方案**：
```bash
# 立即重新构建
npm run build

# 如果问题持续，清除缓存后重新构建
rm -rf dist/
npm run build
```

#### 3.2 配置不生效问题
**错误现象**：
- 修改工具名称后界面没有变化
- 修改图标后仍显示旧图标

**解决方案**：
```bash
# 确保完整重新构建
npm run build

# 检查构建日志确认工具被重新编译
```

#### 3.3 重复显示问题
**错误现象**：
- 同一个工具显示多次
- 工具集图标重复

**解决方案**：
```bash
# 检查配置文件是否有重复导入
grep -r "import.*metaso" .

# 重新构建
npm run build
```

### 4. 最佳实践

#### 4.1 开发流程
```bash
# 标准开发流程
# 1. 修改配置文件
vim children/metasoSearch/src/config.ts

# 2. 立即构建验证
npm run build

# 3. 检查构建结果
# 查看构建日志，确认无错误

# 4. 测试功能
# 在 FastGPT 中测试工具是否正常工作

# 5. 提交代码
git add .
git commit -m "修改工具配置"
```

#### 4.2 调试技巧
```javascript
// 使用脚本验证配置加载
// debug-config.js
const config = require('./config.ts');
console.log('工具集配置:', {
  name: config.default.name,
  childrenCount: config.default.children.length,
  children: config.default.children.map(c => c.name)
});
```

#### 4.3 预防措施
- **及时构建**：每次配置修改后立即构建
- **完整测试**：构建后在 FastGPT 中完整测试功能
- **版本控制**：使用 git 记录每次修改，便于回滚
- **文档记录**：在开发日志中记录重要的配置修改

### 5. 故障排除指南

#### 5.1 快速诊断
```bash
# 1. 检查构建状态
npm run build 2>&1 | grep -E "(error|warning|complete)"

# 2. 检查配置文件语法
node -c config.ts

# 3. 检查子工具导入
node -e "console.log(require('./config.ts').default.children.length)"

# 4. 检查构建产物
ls -la dist/tools/metaso/
```

#### 5.2 完全重置
如果问题持续存在：
```bash
# 1. 清除所有构建缓存
rm -rf dist/
rm -rf node_modules/.cache/
rm -rf .next/

# 2. 重新安装依赖
npm install

# 3. 完全重新构建
npm run build

# 4. 重启开发服务器
npm run dev
```

### 6. 关键要点总结

1. **配置修改后必须重新构建** - 这是最重要的规则
2. **构建过程是配置生效的唯一途径** - 不构建就不会生效
3. **缓存问题可能导致看似正确的配置无法正确显示** - 重新构建是解决方案
4. **及时验证是最佳实践** - 修改后立即构建和测试
5. **完整的构建日志是调试的重要信息** - 关注构建过程的输出

通过遵循这些构建要求和最佳实践，可以有效避免因构建缓存导致的各种显示和功能问题。
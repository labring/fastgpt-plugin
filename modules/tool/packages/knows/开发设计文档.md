# KnowS 医学知识检索插件开发设计文档

## 📋 项目概述

### 项目名称
KnowS 医学知识检索插件 - FastGPT 集成

### 项目描述
基于 KnowS API 的全功能医学知识检索插件，为 FastGPT 提供完整的医学知识服务。采用 children 方法组织多个子工具，支持文献检索、证据分析、场景总结、历史记录管理等功能。通过配置 API Key 激活使用。

### 技术栈
- **运行环境**: Node.js 18+
- **开发语言**: TypeScript (严格模式)
- **包管理器**: Bun
- **测试框架**: Vitest
- **代码规范**: ESLint + Prettier
- **HTTP 客户端**: fetch API
- **架构模式**: children 子工具组织方式
- **api base url**: https://api.nullht.com

## 🚨 重要开发原则

### 开发顺序要求（必须严格遵守）
**⚠️ 关键原则：先开发一个子功能，确保代码完全正确后，再快速开发其他功能**

1. **单一功能优先**：选择最简单的子工具（如 search）先完成开发
2. **完整验证**：确保该子工具的所有代码（config.ts、types.ts、index.ts）都正确无误
3. **构建测试**：运行 `npm run build` 确保构建成功
4. **功能测试**：验证该子工具功能正常
5. **复制扩展**：基于正确的模板快速开发其他子工具
6. **避免全量开发**：禁止一次性开发所有功能后重复修改全部代码

**错误示例**：❌ 同时开发 6 个子工具 → 发现错误 → 修改 6 个文件 → 重复 5 次
**正确示例**：✅ 开发 search 工具 → 验证正确 → 复制模板开发其他 5 个工具

## 🐛 高频错误修复指南

### 1. TypeScript 类型错误

#### 错误1：未定义类型引用
**错误描述**：`Cannot find name 'Evidence'` 或类似的类型未定义错误
**原因**：引用了未定义或未正确导入的类型
**修复方法**：
- 检查类型定义文件中是否存在该类型
- 确保正确导入类型
- 如果类型不存在，需要定义或移除引用

```typescript
// ❌ 错误代码
export interface SearchToolOutput {
  evidences: Evidence[];  // Evidence 类型未定义
}

// ✅ 正确代码
export interface SearchToolOutput {
  evidences: SearchResult[];  // 使用已定义的类型
}

export interface SearchResult {
  id: string;
  title: string;
  content: string;
}
```

#### 错误2：导入路径错误
**错误描述**：`Module '"../shared/types"' has no exported member 'SomeType'`
**原因**：导入路径不正确或导出的成员名称错误
**修复方法**：
- 检查文件路径是否正确
- 确认导出的成员名称
- 使用相对路径时注意层级关系

```typescript
// ❌ 错误代码
import { Evidence } from '../shared/types';  // 路径或导出名错误

// ✅ 正确代码
import { SearchResult } from '../shared/types';  // 确保路径和导出名正确
```

### 2. FastGPT 配置错误

#### 错误3：工具类型枚举错误
**错误描述**：`Type '"tool"' is not assignable to type 'ToolTypeEnum | undefined'`
**原因**：使用了错误的工具类型值
**修复方法**：使用正确的 ToolTypeEnum 枚举值

```typescript
// ❌ 错误代码
export const config = defineToolSet({
  type: 'tool',  // 错误的类型值
  // ...
});

// ✅ 正确代码
export const config = defineToolSet({
  type: ToolTypeEnum.tools,  // 使用正确的枚举值
  // ...
});
```

#### 错误4：配置结构错误
**错误描述**：`Object literal may only specify known properties, and 'version' does not exist`
**原因**：配置对象中使用了不存在的属性名
**修复方法**：使用正确的属性名

```typescript
// ❌ 错误代码
versionList: [
  {
    version: '1.0.0',  // 错误的属性名
    // ...
  }
]

// ✅ 正确代码
versionList: [
  {
    value: '1.0.0',  // 正确的属性名
    // ...
  }
]
```

### 3. 输入输出参数配置错误

#### 错误5：缺少必需的参数属性
**错误描述**：构建时提示缺少 `toolDescription` 或其他必需属性
**原因**：输入参数配置不完整
**修复方法**：添加所有必需的属性

```typescript
// ❌ 错误代码
{
  key: 'query',
  valueType: WorkflowIOValueTypeEnum.string,
  label: '查询内容',
  // 缺少 toolDescription
}

// ✅ 正确代码
{
  key: 'query',
  valueType: WorkflowIOValueTypeEnum.string,
  label: '查询内容',
  toolDescription: '输入要查询的医学问题',  // 添加必需属性
  renderTypeList: [FlowNodeInputTypeEnum.textarea],
  required: true
}
```

### 4. 构建插件错误

#### 错误6：空指针访问错误
**错误描述**：`undefined is not an object (evaluating 'path.node.arguments[0].type')`
**原因**：在访问对象属性前没有检查对象是否存在
**修复方法**：添加存在性检查

```typescript
// ❌ 错误代码
if (path.node.arguments[0].type === 'ObjectExpression') {
  // 直接访问可能为 undefined 的属性
}

// ✅ 正确代码
if (path.node.arguments[0] && path.node.arguments[0].type === 'ObjectExpression') {
  // 先检查对象存在再访问属性
}
```

### 5. 字符编码错误

#### 错误7：全角字符导致语法错误
**错误描述**：意外的字符或语法错误
**原因**：使用了全角标点符号
**修复方法**：所有代码必须使用半角字符

```typescript
// ❌ 错误代码（全角字符）
const config = {
  name: 'KnowS 搜索'，  // 全角逗号
  description: '医学知识检索工具'；  // 全角分号
}

// ✅ 正确代码（半角字符）
const config = {
  name: 'KnowS 搜索',  // 半角逗号
  description: '医学知识检索工具';  // 半角分号
}
```

### 6. 多语言配置错误

#### 错误8：缺少多语言支持
**错误描述**：配置中只有单一语言
**原因**：FastGPT 要求支持多语言配置
**修复方法**：为 name 和 description 添加多语言支持

```typescript
// ❌ 错误代码
name: 'KnowS 搜索',
description: '医学知识检索工具',

// ✅ 正确代码
name: {
  'zh-CN': 'KnowS 搜索',
  'en-US': 'KnowS Search'
},
description: {
  'zh-CN': '医学知识检索工具',
  'en-US': 'Medical knowledge search tool'
},
```

### 7. ToolSet 配置错误（关键错误）

#### 错误9：Cannot read properties of undefined (reading '0')
**错误描述**：FastGPT 主程序无法显示插件，控制台报错 `Cannot read properties of undefined (reading '0')`
**原因**：ToolSet 配置中缺少 `children` 数组配置，或子工具导出结构错误
**修复方法**：
1. 在主配置文件中添加 children 数组
2. 修复所有子工具的导出结构

**主配置文件修复**：
```typescript
// ❌ 错误代码 - 缺少 children 数组
import { defineToolSet } from '@tool/type';
import { ToolTypeEnum } from '@tool/type/tool';

export default defineToolSet({
  name: { 'zh-CN': 'KnowS 医学知识检索' },
  type: ToolTypeEnum.scientific,
  // 缺少 children 数组配置
});

// ✅ 正确代码 - 添加 children 数组
import { defineToolSet } from '@tool/type';
import { ToolTypeEnum } from '@tool/type/tool';
import search from './children/search';
import analysis from './children/analysis';
import summary from './children/summary';
import details from './children/details';
import history from './children/history';
import management from './children/management';

export default defineToolSet({
  name: { 'zh-CN': 'KnowS 医学知识检索' },
  type: ToolTypeEnum.scientific,
  children: [search, analysis, summary, details, history, management]
});
```

**子工具导出结构修复**：
```typescript
// ❌ 错误代码 - 错误的导出结构
import { InputType, OutputType, tool as toolCb } from './src/index';
import config from './config';

export default {
  InputType,
  OutputType,
  toolCb,
  config
};

// ✅ 正确代码 - 使用 exportTool 函数
import config from './config';
import { InputType, OutputType, tool as toolCb } from './src';
import { exportTool } from '@tool/utils/tool';

export default exportTool({
  toolCb,
  InputType,
  OutputType,
  config
});
```

**关键检查点**：
1. 确保主配置文件导入了所有子工具
2. 确保 children 数组包含所有子工具
3. 确保所有子工具使用 exportTool 函数导出
4. 确保导入路径正确（'./src' 而不是 './src/index'）

## API官方文档
/Users/qinxiaoqiang/Downloads/fastgpt-plugin-1/modules/tool/packages/knows/KnowS_API_Documentation.md

## 测试/开发常用指令
- npx tsc --noEmit --skipLibCheck: 类型检查，确保 TypeScript 类型正确
- npx vitest run: 单元测试，使用 Vitest 框架运行 JavaScript/TypeScript

- bun run bulid
- bun run dev


## 🎯 功能需求分析

### 核心功能模块
1. **医学文献检索** (`/knows/ai_search`)
   - 支持自然语言问题查询
   - 返回相关证据和答案
   - 支持多种答案类型 (CLINICAL, RESEARCH, POPULAR_SCIENCE)
   - 支持检索范围配置 (PAPER, PAPER_CN, GUIDE, MEETING)

2. **证据分析** (`/knows/evidence/*`)
   - 单篇证据 AI 总结
   - 所有证据总结（流式）
   - 单篇证据被引内容高亮

3. **场景总结** (`/knows/answer`)
   - 基于检索结果生成场景化答案
   - 支持流式输出

4. **文献详情** (`/knows/evidence/get_*`)
   - 英文文献、中文文献、指南、会议详情获取

5. **历史记录** (`/knows/list_*`)
   - 问题历史记录管理
   - 文献解读历史记录

6. **内容管理** (`/knows/create_evidence_by_pdf_file`, `/knows/auto_tagging`)
   - PDF 文件上传创建证据
   - 自动化标签功能

### 配置要求
- **API Key 管理**: 生产环境 API 密钥配置
- **错误处理**: 完善的错误捕获和用户友好提示
- **模块化架构**: children 子工具组织方式

## 🏗️ 系统架构设计

### 目录结构（完整版）
```
knows/
├── config.ts                # 工具集配置（使用 children 方法）
├── index.ts                 # 主入口文件
├── children/
│   ├── search/              # 医学文献检索子工具
│   │   ├── config.ts        # 检索工具配置
│   │   ├── index.ts         # 检索工具入口
│   │   └── src/
│   │       ├── index.ts     # 检索逻辑实现
│   │       ├── types.ts     # 检索相关类型定义
│   │       └── utils.ts     # 检索工具函数
│   ├── analysis/            # 证据分析子工具
│   │   ├── config.ts        # 分析工具配置
│   │   ├── index.ts         # 分析工具入口
│   │   └── src/
│   │       ├── index.ts     # 分析逻辑实现
│   │       ├── types.ts     # 分析相关类型定义
│   │       └── utils.ts     # 分析工具函数
│   ├── summary/             # 场景总结子工具
│   │   ├── config.ts        # 总结工具配置
│   │   ├── index.ts         # 总结工具入口
│   │   └── src/
│   │       ├── index.ts     # 总结逻辑实现
│   │       ├── types.ts     # 总结相关类型定义
│   │       └── utils.ts     # 总结工具函数
│   ├── details/             # 文献详情子工具
│   │   ├── config.ts        # 详情工具配置
│   │   ├── index.ts         # 详情工具入口
│   │   └── src/
│   │       ├── index.ts     # 详情逻辑实现
│   │       ├── types.ts     # 详情相关类型定义
│   │       └── utils.ts     # 详情工具函数
│   ├── history/             # 历史记录子工具
│   │   ├── config.ts        # 历史记录工具配置
│   │   ├── index.ts         # 历史记录工具入口
│   │   └── src/
│   │       ├── index.ts     # 历史记录逻辑实现
│   │       ├── types.ts     # 历史记录相关类型定义
│   │       └── utils.ts     # 历史记录工具函数
│   └── management/          # 内容管理子工具
│       ├── config.ts        # 内容管理工具配置
│       ├── index.ts         # 内容管理工具入口
│       └── src/
│           ├── index.ts     # 内容管理逻辑实现
│           ├── types.ts     # 内容管理相关类型定义
│           └── utils.ts     # 内容管理工具函数
├── shared/                  # 共享模块
│   ├── types.ts             # 通用类型定义
│   ├── api.ts               # API 客户端
│   ├── config.ts            # 配置管理
│   └── utils.ts             # 通用工具函数
├── package.json
├── tsconfig.json
├── README.md
├── KnowS_API_Documentation.md  # API 文档（保留）
└── INITIAL.md                  # 初始需求（保留）
```

### 核心模块设计

#### 1. 插件配置 (config.ts)
```typescript
export const config = {
  id: 'knows-ai-search',
  name: 'KnowS AI 检索',
  description: '基于 KnowS API 的智能检索插件，提供问答、证据总结和高亮功能',
  version: '1.0.0',
  author: 'Xiaoyibao Team',
  // 输入配置
  input: [
    {
      key: 'apiKey',
      type: 'string',
      label: 'API Key',
      description: 'KnowS API 密钥',
      required: true
    },
    {
      key: 'environment',
      type: 'hidden',
      defaultValue: 'production'
    },
    {
      key: 'searchMode',
      type: 'hidden',
      defaultValue: 'ai_search'
    },
    {
      key: 'query',
      type: 'string',
      label: '查询内容',
      description: '输入问题或证据 ID',
      required: true
    },
    {
      key: 'answerType',
      type: 'multiSelect',
      label: '答案类型',
      description: '选择答案类型（仅问答模式）',
      options: [
        { label: '临床', value: 'CLINICAL' },
        { label: '研究', value: 'RESEARCH' },
        { label: '科普', value: 'POPULAR_SCIENCE' }
      ],
      showCondition: { searchMode: 'ai_search' }
    }
  ],
  // 输出配置
  output: [
    {
      key: 'result',
      type: 'string',
      label: '检索结果',
      description: '处理后的检索结果（默认为临床类型答案）'
    },
    {
      key: 'evidences',
      type: 'array',
      label: '证据列表',
      description: '相关证据信息'
    },
    {
      key: 'metadata',
      type: 'object',
      label: '元数据',
      description: '请求相关的元数据信息'
    }
  ]
};
```

#### 2. API 类型定义 (types/ApiTypes.ts)
```typescript
// 基础响应类型
export interface BaseApiResponse {
  success: boolean;
  message?: string;
  timestamp: number;
}

// AI 搜索请求
export interface AiSearchRequest {
  question: string;
  answer_type: AnswerType[];
}

// AI 搜索响应
export interface AiSearchResponse extends BaseApiResponse {
  data: {
    question_id: string;
    evidences: Evidence[];
    answer?: string;
  };
}

// 证据类型
export interface Evidence {
  evidence_id: string;
  title: string;
  content: string;
  source: string;
  relevance_score: number;
  metadata?: Record<string, any>;
}

// 答案类型枚举
export type AnswerType = 'CLINICAL' | 'RESEARCH' | 'POPULAR_SCIENCE';

// 证据总结请求
export interface EvidenceSummaryRequest {
  evidence_id: string;
}

// 证据总结响应
export interface EvidenceSummaryResponse extends BaseApiResponse {
  data: {
    summary: string;
    key_points: string[];
  };
}

// 证据高亮响应
export interface EvidenceHighlightResponse extends BaseApiResponse {
  data: {
    highlights: HighlightBlock[];
  };
}

// 高亮块类型
export interface HighlightBlock {
  block_id: string;
  block_type: 'header' | 'caption' | 'table' | 'paragraph';
  text: string;
  files: string[];
  page_number: number;
}

// 流式响应类型
export interface StreamResponse {
  created: number;
  data: {
    content?: string;
    type?: 'END';
  };
  id: string;
}

//入口文件需要使用系统提供的 exportTool 服务
import { exportTool } from '@tool/utils/tool'; 使用这个系统服务

s#### 3. 错误处理类型 (types/ErrorTypes.ts)
```typescript
// 错误码常量
export const ERROR_CODES = {
  INVALID_API_KEY: 'INVALID_API_KEY',
  NETWORK_ERROR: 'NETWORK_ERROR',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  INVALID_QUERY: 'INVALID_QUERY',
  API_UNAVAILABLE: 'API_UNAVAILABLE',
  TIMEOUT_ERROR: 'TIMEOUT_ERROR',
  VALIDATION_ERROR: 'VALIDATION_ERROR'
} as const;

export type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES];

// 统一错误处理类
export class KnowsError extends Error {
  constructor(
    message: string,
    public readonly code: ErrorCode,
    public readonly statusCode?: number,
    public readonly originalError?: Error
  ) {
    super(message);
    this.name = 'KnowsError';
  }

  /**
   * 创建用户友好的错误信息
   */
  getUserFriendlyMessage(): string {
    switch (this.code) {
      case ERROR_CODES.INVALID_API_KEY:
        return 'API 密钥无效，请检查配置';
      case ERROR_CODES.NETWORK_ERROR:
        return '网络连接失败，请检查网络状态';
      case ERROR_CODES.RATE_LIMIT_EXCEEDED:
        return 'API 调用频率过高，请稍后重试';
      case ERROR_CODES.INVALID_QUERY:
        return '查询内容格式不正确，请重新输入';
      case ERROR_CODES.API_UNAVAILABLE:
        return 'KnowS 服务暂时不可用，请稍后重试';
      case ERROR_CODES.TIMEOUT_ERROR:
        return '请求超时，请稍后重试';
      default:
        return this.message;
    }
  }
}

// 性能监控类型
export interface PerformanceMetrics {
  requestStartTime: number;
  requestEndTime: number;
  duration: number;
  apiEndpoint: string;
  success: boolean;
  errorCode?: ErrorCode;
  queryLength?: number;
  responseSize?: number;
}
```

#### 4. 配置验证工具 (utils/validation.ts)
```typescript
import { KnowsError, ERROR_CODES } from '../types/ErrorTypes';
import type { PluginInput, AnswerType } from '../types/PluginTypes';

/**
 * 验证 API Key 格式和有效性
 */
export const validateApiKey = (apiKey: string): void => {
  if (!apiKey || apiKey.trim().length === 0) {
    throw new KnowsError('API Key 不能为空', ERROR_CODES.INVALID_API_KEY);
  }
  
  // 检查是否包含测试环境标识
  if (apiKey.toLowerCase().includes('test') || apiKey.toLowerCase().includes('demo')) {
    throw new KnowsError('请使用有效的生产环境 API Key', ERROR_CODES.INVALID_API_KEY);
  }
  
  // API Key 长度验证
  if (apiKey.length < 20) {
    throw new KnowsError('API Key 格式不正确，长度过短', ERROR_CODES.INVALID_API_KEY);
  }
  
  // API Key 格式验证（只允许字母、数字、下划线、连字符）
  const apiKeyPattern = /^[a-zA-Z0-9_-]+$/;
  if (!apiKeyPattern.test(apiKey)) {
    throw new KnowsError('API Key 包含无效字符', ERROR_CODES.INVALID_API_KEY);
  }
};

/**
 * 验证查询内容
 */
export const validateQuery = (query: string): void => {
  if (!query || query.trim().length === 0) {
    throw new KnowsError('查询内容不能为空', ERROR_CODES.INVALID_QUERY);
  }
  
  // 查询长度限制
  if (query.length > 1000) {
    throw new KnowsError('查询内容过长，请控制在1000字符以内', ERROR_CODES.INVALID_QUERY);
  }
  
  // 移除潜在的恶意内容
  const sanitizedQuery = sanitizeInput(query);
  if (sanitizedQuery !== query) {
    throw new KnowsError('查询内容包含不安全字符', ERROR_CODES.VALIDATION_ERROR);
  }
};

/**
 * 验证答案类型
 */
export const validateAnswerType = (answerType: AnswerType[]): void => {
  if (!Array.isArray(answerType) || answerType.length === 0) {
    throw new KnowsError('答案类型不能为空', ERROR_CODES.VALIDATION_ERROR);
  }
  
  const validTypes: AnswerType[] = ['CLINICAL', 'RESEARCH', 'POPULAR_SCIENCE'];
  const invalidTypes = answerType.filter(type => !validTypes.includes(type));
  
  if (invalidTypes.length > 0) {
    throw new KnowsError(
      `无效的答案类型: ${invalidTypes.join(', ')}`, 
      ERROR_CODES.VALIDATION_ERROR
    );
  }
};

/**
 * 输入内容安全清理
 */
export const sanitizeInput = (input: string): string => {
  return input
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // 移除 script 标签
    .replace(/javascript:/gi, '') // 移除 javascript: 协议
    .replace(/on\w+\s*=/gi, '') // 移除事件处理器
    .trim();
};

/**
 * 完整的输入验证
 */
export const validateInput = {
  /**
   * AI 搜索输入验证
   */
  aiSearch: (input: { query: string; answerType: AnswerType[] }): void => {
    validateQuery(input.query);
    validateAnswerType(input.answerType);
  },
  
  /**
   * 完整配置验证
   */
  fullConfig: (input: PluginInput): void => {
    validateApiKey(input.apiKey);
    validateQuery(input.query);
    if (input.answerType) {
      validateAnswerType(input.answerType);
    }
  }
};
```

#### 5. 性能监控工具 (utils/performance.ts)
```typescript
import type { PerformanceMetrics, ErrorCode } from '../types/ErrorTypes';

/**
 * 性能监控类
 */
export class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = [];
  private readonly MAX_METRICS_HISTORY = 100;

  /**
   * 开始性能监控
   */
  startRequest(apiEndpoint: string): number {
    return Date.now();
  }

  /**
   * 结束性能监控并记录指标
   */
  endRequest(
    startTime: number,
    apiEndpoint: string,
    success: boolean,
    errorCode?: ErrorCode,
    queryLength?: number,
    responseSize?: number
  ): PerformanceMetrics {
    const endTime = Date.now();
    const duration = endTime - startTime;

    const metrics: PerformanceMetrics = {
      requestStartTime: startTime,
      requestEndTime: endTime,
      duration,
      apiEndpoint,
      success,
      errorCode,
      queryLength,
      responseSize
    };

    this.recordMetrics(metrics);
    this.logPerformance(metrics);

    return metrics;
  }

  /**
   * 记录性能指标
   */
  private recordMetrics(metrics: PerformanceMetrics): void {
    this.metrics.push(metrics);
    
    // 保持历史记录在合理范围内
    if (this.metrics.length > this.MAX_METRICS_HISTORY) {
      this.metrics = this.metrics.slice(-this.MAX_METRICS_HISTORY);
    }
  }

  /**
   * 记录性能日志
   */
  private logPerformance(metrics: PerformanceMetrics): void {
    const { apiEndpoint, duration, success, errorCode, queryLength } = metrics;
    
    // 基础性能日志
    console.log(
      `[Performance] ${apiEndpoint}: ${duration}ms, ` +
      `Success: ${success}, Query Length: ${queryLength || 'N/A'}`
    );

    // 性能警告
    if (duration > 10000) {
      console.warn(`[Performance Warning] 请求耗时过长: ${duration}ms`);
    }

    if (duration > 30000) {
      console.error(`[Performance Error] 请求严重超时: ${duration}ms`);
    }

    // 错误日志
    if (!success && errorCode) {
      console.error(`[Performance Error] 请求失败: ${errorCode}, 耗时: ${duration}ms`);
    }
  }

  /**
   * 获取性能统计信息
   */
  getStatistics(): {
    totalRequests: number;
    successRate: number;
    averageDuration: number;
    maxDuration: number;
    minDuration: number;
  } {
    if (this.metrics.length === 0) {
      return {
        totalRequests: 0,
        successRate: 0,
        averageDuration: 0,
        maxDuration: 0,
        minDuration: 0
      };
    }

    const successfulRequests = this.metrics.filter(m => m.success).length;
    const durations = this.metrics.map(m => m.duration);

    return {
      totalRequests: this.metrics.length,
      successRate: (successfulRequests / this.metrics.length) * 100,
      averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,
      maxDuration: Math.max(...durations),
      minDuration: Math.min(...durations)
    };
  }
}

// 全局性能监控实例
export const performanceMonitor = new PerformanceMonitor();

/**
 * 性能监控装饰器
 */
export const withPerformanceMonitoring = <T extends any[], R>(
  fn: (...args: T) => Promise<R>,
  apiEndpoint: string
) => {
  return async (...args: T): Promise<R> => {
    const startTime = performanceMonitor.startRequest(apiEndpoint);
    let success = false;
    let errorCode: ErrorCode | undefined;
    let result: R;

    try {
      result = await fn(...args);
      success = true;
      return result;
    } catch (error) {
      if (error instanceof KnowsError) {
        errorCode = error.code;
      }
      throw error;
    } finally {
      performanceMonitor.endRequest(
        startTime,
        apiEndpoint,
        success,
        errorCode
      );
    }
  };
};
```

#### 6. 错误处理工具 (utils/errorHandler.ts)
```typescript
import { KnowsError, ERROR_CODES, type ErrorCode } from '../types/ErrorTypes';

/**
 * 统一错误处理器
 */
export class ErrorHandler {
  /**
   * 处理 API 响应错误
   */
  static handleApiError(error: any, endpoint: string): never {
    console.error(`[ErrorHandler] API 错误 ${endpoint}:`, error);

    if (error instanceof KnowsError) {
      throw error;
    }

    // 网络错误
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      throw new KnowsError(
        '网络连接失败，请检查网络状态',
        ERROR_CODES.NETWORK_ERROR,
        undefined,
        error
      );
    }

    // HTTP 状态码错误
    if (error.status) {
      switch (error.status) {
        case 401:
          throw new KnowsError(
            'API 密钥无效或已过期',
            ERROR_CODES.INVALID_API_KEY,
            401,
            error
          );
        case 429:
          throw new KnowsError(
            'API 调用频率过高，请稍后重试',
            ERROR_CODES.RATE_LIMIT_EXCEEDED,
            429,
            error
          );
        case 500:
        case 502:
        case 503:
          throw new KnowsError(
            'KnowS 服务暂时不可用，请稍后重试',
            ERROR_CODES.API_UNAVAILABLE,
            error.status,
            error
          );
        case 408:
          throw new KnowsError(
            '请求超时，请稍后重试',
            ERROR_CODES.TIMEOUT_ERROR,
            408,
            error
          );
        default:
          throw new KnowsError(
            `API 请求失败: ${error.status} ${error.statusText}`,
            ERROR_CODES.NETWORK_ERROR,
            error.status,
            error
          );
      }
    }

    // 超时错误
    if (error.name === 'AbortError' || error.message.includes('timeout')) {
      throw new KnowsError(
        '请求超时，请稍后重试',
        ERROR_CODES.TIMEOUT_ERROR,
        undefined,
        error
      );
    }

    // 未知错误
    throw new KnowsError(
      error.message || '未知错误，请稍后重试',
      ERROR_CODES.NETWORK_ERROR,
      undefined,
      error
    );
  }

  /**
   * 处理验证错误
   */
  static handleValidationError(message: string, originalError?: Error): never {
    throw new KnowsError(
      message,
      ERROR_CODES.VALIDATION_ERROR,
      undefined,
      originalError
    );
  }

  /**
   * 获取用户友好的错误信息
   */
  static getUserFriendlyMessage(error: any): string {
    if (error instanceof KnowsError) {
      return error.getUserFriendlyMessage();
    }

    // 默认错误信息
    return 'KnowS 检索遇到未知错误，请稍后重试';
  }
}
```
``
#### 7. API 客户端 (services/apiClient.ts)
```typescript
import type { 
  AiSearchRequest, 
  AiSearchResponse
} from '../types/ApiTypes';
import { ErrorHandler } from '../utils/errorHandler';
import { performanceMonitor } from '../utils/performance';

export class KnowsApiClient {
  private baseUrl: string;
  private apiKey: string;
  private readonly timeout: number = 30000; // 30秒超时

  constructor(apiKey: string) {
    this.baseUrl = 'https://api.nullht.com'; // 固定使用生产环境
    this.apiKey = apiKey;
  }

  /**
   * 通用请求方法，集成错误处理和性能监控
   */
  private async request<T>(
    endpoint: string, 
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    const startTime = performanceMonitor.startRequest(endpoint);
    
    try {
      // 创建 AbortController 用于超时控制
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);

      const response = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          ...options.headers,
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorData = await response.text();
        const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
        (error as any).status = response.status;
        (error as any).statusText = response.statusText;
        (error as any).responseData = errorData;
        throw error;
      }

      const data = await response.json();
      
      // 记录成功的性能指标
      performanceMonitor.endRequest(
        startTime,
        endpoint,
        true,
        undefined,
        options.body ? (options.body as string).length : undefined,
        JSON.stringify(data).length
      );

      return data;
    } catch (error) {
      // 记录失败的性能指标
      performanceMonitor.endRequest(
        startTime,
        endpoint,
        false,
        undefined,
        options.body ? (options.body as string).length : undefined
      );

      // 统一错误处理
      ErrorHandler.handleApiError(error, endpoint);
    }
  }

  /**
   * AI 问答检索
   */
  async aiSearch(request: AiSearchRequest): Promise<AiSearchResponse> {
    console.log(`[KnowsApiClient] 发起 AI 搜索请求: ${request.question.substring(0, 50)}...`);
    
    return this.request<AiSearchResponse>('/knows/ai_search', {
      method: 'POST',
      body: JSON.stringify(request),
    });
  }
}
```

#### 8. 服务层 (services/knowsService.ts)
```typescript
import { KnowsApiClient } from './apiClient';
import type { 
  AiSearchRequest, 
  AiSearchResponse,
  PluginInput,
  PluginOutput 
} from '../types/ApiTypes';
import { validateInput } from '../utils/validation';
import { ErrorHandler } from '../utils/errorHandler';
import { performanceMonitor } from '../utils/performance';

export class KnowsService {
  private apiClient: KnowsApiClient;

  constructor(apiKey: string) {
    this.apiClient = new KnowsApiClient(apiKey);
  }

  /**
   * 处理 AI 问答检索，集成输入验证和错误处理
   */
  async handleAiSearch(input: PluginInput): Promise<PluginOutput> {
    const startTime = Date.now();
    
    try {
      console.log('[KnowsService] 开始处理 AI 搜索请求');
      
      // 输入验证
      const validationResult = validateInput(input);
      if (!validationResult.isValid) {
        throw ErrorHandler.createValidationError(validationResult.errors);
      }

      // 构建 API 请求
      const request: AiSearchRequest = {
        question: validationResult.sanitizedInput.question,
        answer_type: validationResult.sanitizedInput.answerType || ['CLINICAL'],
        top_k: 10,
        score_threshold: 0.5
      };

      console.log(`[KnowsService] 发送请求到 API: ${request.question.substring(0, 50)}...`);
      
      // 调用 API
      const response = await this.apiClient.aiSearch(request);
      
      // 验证响应数据
      if (!response || !response.data) {
        throw new Error('API 返回数据格式错误');
      }

      // 记录性能指标
      const duration = Date.now() - startTime;
      performanceMonitor.recordMetric({
        operation: 'ai_search',
        duration,
        success: true,
        timestamp: new Date(),
        metadata: {
          questionLength: request.question.length,
          resultCount: response.data.length
        }
      });

      console.log(`[KnowsService] AI 搜索完成，返回 ${response.data.length} 条结果，耗时 ${duration}ms`);

      // 构建返回结果
      return {
        result: response.data.map(item => ({
          title: item.title || '无标题',
          content: item.content || '',
          score: item.score || 0,
          source: item.source || '未知来源'
        })),
        metadata: {
          total: response.data.length,
          query: request.question,
          timestamp: new Date().toISOString(),
          processingTime: duration
        }
      };

    } catch (error) {
      // 记录失败的性能指标
      const duration = Date.now() - startTime;
      performanceMonitor.recordMetric({
        operation: 'ai_search',
        duration,
        success: false,
        timestamp: new Date(),
        error: error instanceof Error ? error.message : '未知错误'
      });

      console.error('[KnowsService] AI 搜索失败:', error);
      
      // 统一错误处理
      throw ErrorHandler.handleServiceError(error, 'AI 搜索');
    }
  }
}
```

#### 9. 主入口文件 (index.ts)
```typescript
import { KnowsService } from './services/knowsService';
import type { PluginInput, PluginOutput } from './types/ApiTypes';
import { validateInput } from './utils/validation';
import { ErrorHandler } from './utils/errorHandler';
import { performanceMonitor } from './utils/performance';

/**
 * Knows 插件主入口函数
 * 集成输入验证、错误处理和性能监控
 */
export default async function main(input: PluginInput): Promise<PluginOutput> {
  const startTime = Date.now();
  
  try {
    console.log('[Knows Plugin] 开始处理请求');
    
    // 基础输入验证
    if (!input) {
      throw ErrorHandler.createValidationError(['输入参数不能为空']);
    }

    // API Key 验证
    if (!input.apiKey) {
      throw ErrorHandler.createValidationError(['API Key 不能为空']);
    }

    // 详细输入验证
    const validationResult = validateInput(input);
    if (!validationResult.isValid) {
      throw ErrorHandler.createValidationError(validationResult.errors);
    }

    console.log(`[Knows Plugin] 输入验证通过，问题: ${input.question.substring(0, 50)}...`);

    // 初始化服务
    const knowsService = new KnowsService(input.apiKey);
    
    // 执行 AI 问答检索
    const result = await knowsService.handleAiSearch(input);
    
    // 记录成功的性能指标
    const duration = Date.now() - startTime;
    performanceMonitor.recordMetric({
      operation: 'plugin_main',
      duration,
      success: true,
      timestamp: new Date(),
      metadata: {
        questionLength: input.question.length,
        resultCount: result.result.length
      }
    });

    console.log(`[Knows Plugin] 请求处理完成，耗时 ${duration}ms`);
    
    return result;

  } catch (error) {
    // 记录失败的性能指标
    const duration = Date.now() - startTime;
    performanceMonitor.recordMetric({
      operation: 'plugin_main',
      duration,
      success: false,
      timestamp: new Date(),
      error: error instanceof Error ? error.message : '未知错误'
    });

    console.error('[Knows Plugin] 请求处理失败:', error);
    
    // 统一错误处理并返回用户友好的错误信息
    const handledError = ErrorHandler.handleServiceError(error, 'Knows 插件');
    
    // 返回错误结果而不是抛出异常，确保插件稳定性
    return {
      result: [],
      metadata: {
        total: 0,
        query: input?.question || '',
        timestamp: new Date().toISOString(),
        processingTime: duration,
        error: handledError.message
      }
    };
  }
}
```

## 🧪 测试策略

### 测试覆盖范围
1. **单元测试**: 各个服务模块的功能测试
2. **集成测试**: API 客户端与真实 API 的集成测试
3. **错误处理测试**: 各种异常情况的处理测试
4. **边界条件测试**: 输入验证和边界值测试

### 开发日志

### 2024-12-19 TypeScript类型错误修复
**修复内容：**
1. **ErrorTypes.ts类型定义优化**
   - 修复KnowsError类构造函数中的可选参数处理
   - 使用空值合并操作符(??)替代逻辑或操作符(||)
   - 优化PerformanceMetrics接口，将error和metadata设为可选属性

2. **validation.ts类型兼容性修复**
   - 修复answerType字段的undefined类型问题
   - 为answerType提供默认值['CLINICAL']，避免undefined赋值

3. **performance.ts性能监控修复**
   - 修复recordMetric方法中的语法错误
   - 优化性能指标记录，使用条件属性展开语法
   - 确保可选属性的正确处理

4. **apiClient.ts泛型类型修复**
   - 添加类型断言(as T)解决泛型返回类型问题
   - 确保API响应数据的类型安全

5. **errorHandler.ts错误处理优化**
   - 简化isRetryableError方法的实现
   - 明确定义可重试错误码类型
   - 提高代码可读性和类型安全性

6. **测试文件导入路径修复**
   - 修正测试文件中的相对导入路径
   - 确保测试能够正确运行

**技术要点：**
- 严格遵循TypeScript的exactOptionalPropertyTypes配置
- 使用现代JavaScript语法(空值合并、条件属性展开)
- 保持代码的类型安全和运行时稳定性
- 优化错误处理和性能监控的实现

### 2024-12-19 代码实现完成

#### 核心代码开发
1. **项目结构搭建**
   - 创建 `package.json` 和 `tsconfig.json` 配置文件
   - 设置 TypeScript 编译配置和项目依赖
   - 配置 ESLint 代码规范和 Vitest 测试框架

2. **类型定义实现** (`src/types/`)
   - `ApiTypes.ts`: 定义插件输入输出、API 请求响应等核心类型
   - `ErrorTypes.ts`: 实现统一错误类型、错误码常量和 `KnowsError` 类
   - 提供完整的 TypeScript 类型安全支持

3. **工具函数开发** (`src/utils/`)
   - `validation.ts`: 实现输入验证、API Key 格式检查、内容清理等功能
   - `performance.ts`: 开发性能监控类，支持请求耗时统计和成功率监控
   - `errorHandler.ts`: 创建统一错误处理机制，提供用户友好错误信息

4. **服务层实现** (`src/services/`)
   - `apiClient.ts`: 实现 HTTP 客户端，集成超时控制、错误处理和性能监控
   - `knowsService.ts`: 开发业务逻辑层，处理 AI 搜索请求和结果格式化

5. **主入口开发** (`src/index.ts`)
   - 集成所有模块，实现完整的插件功能
   - 添加全面的错误处理和性能监控
   - 确保插件稳定性，错误时返回结果而非抛出异常

#### 测试和质量保证
1. **单元测试编写**
   - `__tests__/index.test.ts`: 主入口函数测试
   - `__tests__/validation.test.ts`: 输入验证工具测试
   - 配置 Vitest 测试框架和覆盖率报告

2. **代码质量工具**
   - ESLint 配置，确保代码规范一致性
   - TypeScript 严格模式，提供类型安全保障
   - 完整的项目文档和 README

#### 技术特性
- **类型安全**: 完整的 TypeScript 类型定义，避免运行时错误
- **错误处理**: 统一的错误处理机制，用户友好的错误信息
- **性能监控**: 实时性能指标记录，支持问题排查和优化
- **输入验证**: 全面的参数验证和内容清理，防止恶意输入
- **模块化设计**: 清晰的代码结构，便于维护和扩展

#### 代码质量亮点
- 使用装饰器模式实现性能监控
- 实现了可重试错误判断机制
- 添加了 API 健康检查功能
- 支持性能数据自动清理，避免内存泄漏
- 提供详细的错误上下文信息

### 2024-12-19 API URL 修正
- **修正生产环境 API URL**: 根据官方 API 文档，将 base URL 修正为 `https://api.nullht.com`
- **确保 API 调用正确性**: 更新后的 URL 与官方文档保持一致，确保 API 调用能够正常工作

### 2024-12-19 代码质量优化

#### 主要优化内容
1. **错误处理标准化**
   - 新增 `ErrorTypes.ts` 定义统一错误类型和错误码
   - 实现 `KnowsError` 类提供用户友好的错误信息
   - 在 API 客户端、服务层和主入口文件中集成统一错误处理

2. **配置验证机制**
   - 新增 `utils/validation.ts` 提供完整的输入验证
   - 实现 `validateApiKey`、`validateQuery`、`validateAnswerType` 等验证函数
   - 添加输入内容清理功能 `sanitizeInput`

3. **性能监控和日志**
   - 新增 `utils/performance.ts` 实现性能监控类 `PerformanceMonitor`
   - 集成请求耗时统计、成功率监控、错误追踪
   - 在关键节点添加性能指标记录和日志输出

#### 技术要点
- **API 客户端优化**: 添加超时控制（30秒）、AbortController 支持、详细错误信息记录
- **服务层增强**: 集成输入验证、响应数据验证、性能指标记录
- **主入口稳定性**: 改为返回错误结果而非抛出异常，确保插件稳定性

#### 错误处理改进
- 统一错误码定义（VALIDATION_ERROR、API_ERROR、NETWORK_ERROR、TIMEOUT_ERROR）
- 用户友好错误信息映射
- 详细的错误上下文记录

#### 性能监控特性
- 请求级别的耗时统计
- 操作成功率追踪
- 数据传输量监控
- 错误分类统计

#### 代码质量提升
- 增强类型安全性
- 完善输入验证和清理
- 统一日志格式和错误处理
- 模块化设计便于维护和扩展

这些优化确保了代码的健壮性、可维护性和用户体验，为后续功能扩展奠定了坚实基础。

## 测试用例

### 测试用例设计
```typescript
// src/__tests__/index.test.ts
describe('KnowS Plugin', () => {
  describe('AI 搜索模式', () => {
    it('应该正确处理有效的问答请求', async () => {
      const input = {
        apiKey: 'your-production-api-key',
        searchMode: 'ai_search',
        query: '老年癌症患者出现眩晕和心悸的原因',
        answerType: ['CLINICAL']
      };
      
      const result = await handler(input);
      expect(result).toHaveProperty('result');
      expect(result).toHaveProperty('evidences');
    });
  });

  describe('错误处理', () => {
    it('应该处理缺失 API Key 的情况', async () => {
      const input = {
        searchMode: 'ai_search',
        query: '测试问题'
      };
      
      await expect(handler(input)).rejects.toThrow('API Key 不能为空');
    });
  });
});
```

## 📚 文档规范

### README.md 内容
- 插件功能介绍
- 安装和配置说明
- 使用示例和最佳实践
- API 参考文档
- 故障排除指南

### 代码注释规范
- 关键业务逻辑添加中文注释
- API 接口方法提供完整的 JSDoc 注释
- 复杂算法和数据处理逻辑详细说明

## 🚀 部署和发布

### 发布前检查清单
- [ ] 所有测试用例通过
- [ ] TypeScript 类型检查无错误
- [ ] ESLint 代码规范检查通过
- [ ] API 密钥安全性检查
- [ ] 文档完整性检查
- [ ] 版本号更新

### 版本管理策略
- **主版本**: 重大功能变更或 API 不兼容更新
- **次版本**: 新功能添加，向后兼容
- **修订版本**: Bug 修复和性能优化

## ⚠️ 风险评估和缓解

### 技术风险
1. **API 限流**: 实现请求频率控制和重试机制
2. **网络超时**: 设置合理的超时时间和错误处理
3. **数据安全**: API Key 加密存储，避免日志泄露

### 业务风险
1. **服务可用性**: 实现降级策略和错误提示
2. **用户体验**: 提供清晰的错误信息和使用指导
3. **性能影响**: 优化请求处理和响应时间

## 📈 后续优化方向

### 功能增强
1. **缓存机制**: 实现智能缓存减少重复请求
2. **批量处理**: 支持批量查询和处理
3. **结果过滤**: 提供更精细的结果筛选选项

### 性能优化
1. **并发控制**: 优化并发请求处理
2. **内存管理**: 优化大数据量处理的内存使用
3. **响应压缩**: 实现响应数据压缩传输

---

**本设计文档遵循 FastGPT 插件开发最佳实践，确保代码质量、可维护性和用户体验。** 🎯